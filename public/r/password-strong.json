{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "password-strong",
  "type": "registry:component",
  "description": "Beautiful Password component which measures the strength of password with a touch of dotted background glowing pattern.",
  "files": [
    {
      "path": "src/registry/new-york/items/password-strong/components/password.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useMemo, useState } from \"react\";\r\nimport { Eye, EyeOff } from \"lucide-react\";\r\nimport { motion } from \"motion/react\";\r\nimport { DottedGlowBackground } from \"./dotted-glow-bg\";\r\n\r\nconst PASSWORD_REQUIREMENTS = [\r\n  { regex: /[0-9]/, text: \"Password must contain at least 1 number.\" },\r\n  { regex: /[a-z]/, text: \"Password must contain at least 1 lowercase letter\" },\r\n  { regex: /[A-Z]/, text: \"Password must contain at least 1 uppercase letter\" },\r\n  {\r\n    regex: /[!-\\/:-@[-`{-~]/,\r\n    text: \"Password must contain at least 1 special character\",\r\n  },\r\n  { regex: /.{8,}/, text: \"Password must contain at least 8 characters\" },\r\n] as const;\r\n\r\ntype StrengthScore = 0 | 1 | 2 | 3 | 4 | 5;\r\nconst levels = [1, 2, 3, 4, 5];\r\nconst colors = [\r\n  \"bg-red-200\",\r\n  \"bg-red-300\",\r\n  \"bg-red-400\",\r\n  \"bg-green-500\",\r\n  \"bg-green-600\",\r\n];\r\nconst STRENGTH_TEXTS: Record<Exclude<StrengthScore, 5>, string> = {\r\n  0: \"Enter a password\",\r\n  1: \"Weak password\",\r\n  2: \"Medium password!\",\r\n  3: \"Strong password!!\",\r\n  4: \"Very Strong password!!!\",\r\n};\r\n\r\ninterface PasswordProps {\r\n  value?: string;\r\n  onChange?: (password: string) => void;\r\n  onStrengthChange?: (score: StrengthScore) => void;\r\n}\r\n\r\nexport default function Password({\r\n  value: controlledValue,\r\n  onChange,\r\n  onStrengthChange,\r\n}: PasswordProps = {}) {\r\n  const [internalPassword, setInternalPassword] = useState(\"\");\r\n  const [visible, setVisible] = useState(false);\r\n  const [prevStrength, setPrevStrength] = useState(0);\r\n  const [shouldAnimate, setShouldAnimate] = useState(false);\r\n\r\n  // Use controlled value if provided, otherwise use internal state\r\n  const password =\r\n    controlledValue !== undefined ? controlledValue : internalPassword;\r\n\r\n  const strength = useMemo(() => {\r\n    const requirements = PASSWORD_REQUIREMENTS.map((r) => ({\r\n      met: r.regex.test(password),\r\n      text: r.text,\r\n    }));\r\n    return {\r\n      score: requirements.filter((r) => r.met).length as StrengthScore,\r\n      requirements,\r\n    };\r\n  }, [password]);\r\n\r\n  const isVeryStrong = strength.score >= 5;\r\n\r\n  useEffect(() => {\r\n    // Check if we just became very strong\r\n    if (strength.score >= 5 && prevStrength < 5) {\r\n      setShouldAnimate(true);\r\n      // Reset animation trigger after animation completes\r\n      const timer = setTimeout(() => {\r\n        setShouldAnimate(false);\r\n      }, 1000); // Duration covers both scale and vibration\r\n\r\n      return () => clearTimeout(timer);\r\n    }\r\n    setPrevStrength(strength.score);\r\n  }, [strength.score, prevStrength]);\r\n\r\n  // Notify parent of strength changes\r\n  useEffect(() => {\r\n    if (onStrengthChange) {\r\n      onStrengthChange(strength.score);\r\n    }\r\n  }, [strength.score, onStrengthChange]);\r\n\r\n  const message =\r\n    password.length === 0\r\n      ? STRENGTH_TEXTS[0]\r\n      : strength.requirements.find((r) => !r.met)\r\n        ? `${strength.requirements.find((r) => !r.met)!.text}`\r\n        : STRENGTH_TEXTS[\r\n            Math.min(strength.score, 4) as keyof typeof STRENGTH_TEXTS\r\n          ];\r\n\r\n  const msgColorClass =\r\n    message === STRENGTH_TEXTS[0]\r\n      ? \"text-neutral-400\"\r\n      : message === STRENGTH_TEXTS[4]\r\n        ? \"text-green-500\"\r\n        : \"text-red-500\";\r\n\r\n  return (\r\n    <div className=\"relative mx-auto mt-8 flex w-xl max-w-2xl flex-col justify-center gap-2 rounded-2xl border border-neutral-300 bg-white p-4 shadow-[0_3px_10px_rgb(0,0,0,0.2)] dark:border-neutral-950 dark:bg-black dark:shadow-none\">\r\n      <DottedGlowBackground\r\n        className=\"pointer-events-none mask-radial-to-90% mask-radial-at-center\"\r\n        opacity={1}\r\n        gap={20}\r\n        radius={1}\r\n        colorLightVar=\"--color-neutral-500\"\r\n        glowColorLightVar=\"--color-neutral-600\"\r\n        colorDarkVar=\"--color-neutral-500\"\r\n        glowColorDarkVar=\"--color-sky-800\"\r\n        backgroundOpacity={0}\r\n        speedMin={0.3}\r\n        speedMax={1.6}\r\n        speedScale={1}\r\n      />\r\n      <div className=\"z-999 flex w-full flex-col gap-2\">\r\n        <label\r\n          htmlFor=\"password\"\r\n          className=\"text-sm font-semibold text-neutral-800 dark:text-neutral-100\"\r\n        >\r\n          Password\r\n        </label>\r\n\r\n        <div className=\"relative\">\r\n          <input\r\n            id=\"password\"\r\n            name=\"password\"\r\n            type={visible ? \"text\" : \"password\"}\r\n            value={password}\r\n            onChange={(e) => {\r\n              const newValue = e.target.value;\r\n              if (onChange) {\r\n                onChange(newValue);\r\n              } else {\r\n                setInternalPassword(newValue);\r\n              }\r\n            }}\r\n            placeholder=\"Enter your password\"\r\n            aria-invalid={strength.score < 4}\r\n            aria-describedby=\"password-strength\"\r\n            className=\"text-md <dark:focus:ring-gray-400></dark:focus:ring-gray-400> block w-full rounded-md border-0 bg-white px-4 py-1 ring-1 ring-neutral-400 transition-all duration-200 ease-in-out placeholder:text-neutral-400 focus:ring-2 focus:ring-gray-500 focus:outline-none dark:bg-black dark:ring-neutral-600\"\r\n          />\r\n          <motion.button\r\n            type=\"button\"\r\n            onClick={() => setVisible((v) => !v)}\r\n            aria-label={visible ? \"Hide password\" : \"Show password\"}\r\n            className=\"absolute inset-y-0 right-0 flex cursor-pointer items-center pr-3\"\r\n            whileTap={{ scale: 0.95 }}\r\n            transition={{\r\n              duration: 0.2,\r\n              ease: \"easeInOut\",\r\n            }}\r\n          >\r\n            <motion.div\r\n              key={visible ? \"eye-off\" : \"eye-on\"}\r\n              initial={{ scale: 0 }}\r\n              animate={{ scale: 1 }}\r\n              exit={{ scale: 0 }}\r\n              transition={{\r\n                type: \"spring\",\r\n                stiffness: 300,\r\n                damping: 20,\r\n                duration: 0.3,\r\n              }}\r\n            >\r\n              {visible ? <EyeOff size={16} /> : <Eye size={16} />}\r\n            </motion.div>\r\n          </motion.button>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"z-999 mt-2 flex w-full justify-between gap-2\">\r\n        {levels.map((lvl, i) => (\r\n          <div\r\n            key={lvl}\r\n            className=\"relative h-1 w-full overflow-hidden rounded-full border border-neutral-300 bg-neutral-400\"\r\n          >\r\n            <motion.div\r\n              className={`h-full rounded-full ${colors[i]}`}\r\n              initial={{ width: 0 }}\r\n              animate={{\r\n                width: strength.score >= lvl ? \"100%\" : 0,\r\n              }}\r\n              transition={{\r\n                duration: 0.3,\r\n                delay:\r\n                  strength.score >= lvl\r\n                    ? i * 0.1\r\n                    : (levels.length - 1 - i) * 0.1,\r\n                ease: \"easeInOut\",\r\n              }}\r\n            />\r\n          </div>\r\n        ))}\r\n      </div>\r\n\r\n      <div className=\"z-999 flex items-center justify-between\">\r\n        <motion.p\r\n          id=\"password-strength\"\r\n          className={`my-2 text-sm font-medium ${msgColorClass}`}\r\n          initial={{\r\n            opacity: 0,\r\n\r\n            y: -3,\r\n            filter: \"blur(4px)\",\r\n          }}\r\n          animate={{ opacity: 1, y: 0, filter: \"blur(0px)\" }}\r\n          transition={{ duration: 0.3 }}\r\n          key={message}\r\n        >\r\n          {message}\r\n        </motion.p>\r\n\r\n        <motion.svg\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n          width=\"24\"\r\n          height=\"24\"\r\n          viewBox=\"0 0 24 24\"\r\n          fill=\"none\"\r\n          stroke={\r\n            strength.score === 0\r\n              ? \"#737373\"\r\n              : isVeryStrong\r\n                ? \"#22c55e\"\r\n                : \"#dc2626\"\r\n          }\r\n          strokeWidth=\"2\"\r\n          strokeLinecap=\"round\"\r\n          strokeLinejoin=\"round\"\r\n          className=\"icon icon-tabler icons-tabler-outline icon-tabler-lock\"\r\n          whileHover={{\r\n            scale: [1, 1.5, 1],\r\n            x: [0, -3, 4, -3, 4, -3, 0],\r\n          }}\r\n          animate={{\r\n            scale: shouldAnimate ? [1, 1.5, 1] : 1,\r\n            x: shouldAnimate ? [0, -3, 4, -3, 4, -3, 0] : 0,\r\n            stroke:\r\n              strength.score === 0\r\n                ? \"#737373\"\r\n                : isVeryStrong\r\n                  ? \"#22c55e\"\r\n                  : \"#dc2626\",\r\n          }}\r\n          transition={{\r\n            scale: { duration: 0.6, ease: \"easeInOut\" },\r\n            x: { duration: 0.4, ease: \"easeInOut\", delay: 0.2 },\r\n            stroke: { duration: 0.3, ease: \"easeInOut\" },\r\n          }}\r\n        >\r\n          <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n          <path d=\"M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z\" />\r\n          <path d=\"M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0\" />\r\n          <path d=\"M8 11v-4a4 4 0 1 1 8 0v4\" />\r\n        </motion.svg>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/new-york/items/password-strong/components/dotted-glow-bg.tsx",
      "content": "import React, { useEffect, useRef, useState } from \"react\";\r\n\r\ntype DottedGlowBackgroundProps = {\r\n  className?: string;\r\n  /** distance between dot centers in pixels */\r\n  gap?: number;\r\n  /** base radius of each dot in CSS px */\r\n  radius?: number;\r\n  /** dot color (will pulse by alpha) */\r\n  color?: string;\r\n  /** optional dot color for dark mode */\r\n  darkColor?: string;\r\n  /** shadow/glow color for bright dots */\r\n  glowColor?: string;\r\n  /** optional glow color for dark mode */\r\n  darkGlowColor?: string;\r\n  /** optional CSS variable name for light dot color (e.g. --color-zinc-900) */\r\n  colorLightVar?: string;\r\n  /** optional CSS variable name for dark dot color (e.g. --color-zinc-100) */\r\n  colorDarkVar?: string;\r\n  /** optional CSS variable name for light glow color */\r\n  glowColorLightVar?: string;\r\n  /** optional CSS variable name for dark glow color */\r\n  glowColorDarkVar?: string;\r\n  /** global opacity for the whole layer */\r\n  opacity?: number;\r\n  /** background radial fade opacity (0 = transparent background) */\r\n  backgroundOpacity?: number;\r\n  /** minimum per-dot speed in rad/s */\r\n  speedMin?: number;\r\n  /** maximum per-dot speed in rad/s */\r\n  speedMax?: number;\r\n  /** global speed multiplier for all dots */\r\n  speedScale?: number;\r\n};\r\n\r\n/**\r\n * Canvas-based dotted background that randomly glows and dims.\r\n * - Uses a stable grid of dots.\r\n * - Each dot gets its own phase + speed producing organic shimmering.\r\n * - Handles high-DPI and resizes via ResizeObserver.\r\n */\r\nexport const DottedGlowBackground: React.FC<DottedGlowBackgroundProps> = ({\r\n  className,\r\n  gap = 12,\r\n  radius = 2,\r\n  color = \"rgba(0,0,0,0.7)\",\r\n  darkColor,\r\n  glowColor = \"rgba(0, 170, 255, 0.85)\",\r\n  darkGlowColor,\r\n  colorLightVar,\r\n  colorDarkVar,\r\n  glowColorLightVar,\r\n  glowColorDarkVar,\r\n  opacity = 0.6,\r\n  backgroundOpacity = 0,\r\n  speedMin = 0.4,\r\n  speedMax = 1.3,\r\n  speedScale = 1,\r\n}) => {\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const [resolvedColor, setResolvedColor] = useState<string>(color);\r\n  const [resolvedGlowColor, setResolvedGlowColor] = useState<string>(glowColor);\r\n\r\n  // Resolve CSS variable value from the container or root\r\n  const resolveCssVariable = (\r\n    el: Element,\r\n    variableName?: string,\r\n  ): string | null => {\r\n    if (!variableName) return null;\r\n    const normalized = variableName.startsWith(\"--\")\r\n      ? variableName\r\n      : `--${variableName}`;\r\n    const fromEl = getComputedStyle(el as Element)\r\n      .getPropertyValue(normalized)\r\n      .trim();\r\n    if (fromEl) return fromEl;\r\n    const root = document.documentElement;\r\n    const fromRoot = getComputedStyle(root).getPropertyValue(normalized).trim();\r\n    return fromRoot || null;\r\n  };\r\n\r\n  const detectDarkMode = (): boolean => {\r\n    const root = document.documentElement;\r\n    if (root.classList.contains(\"dark\")) return true;\r\n    if (root.classList.contains(\"light\")) return false;\r\n    return (\r\n      window.matchMedia &&\r\n      window.matchMedia(\"(prefers-color-scheme: dark)\").matches\r\n    );\r\n  };\r\n\r\n  // Keep resolved colors in sync with theme changes and prop updates\r\n  useEffect(() => {\r\n    const container = containerRef.current ?? document.documentElement;\r\n\r\n    const compute = () => {\r\n      const isDark = detectDarkMode();\r\n\r\n      let nextColor: string = color;\r\n      let nextGlow: string = glowColor;\r\n\r\n      if (isDark) {\r\n        const varDot = resolveCssVariable(container, colorDarkVar);\r\n        const varGlow = resolveCssVariable(container, glowColorDarkVar);\r\n        nextColor = varDot || darkColor || nextColor;\r\n        nextGlow = varGlow || darkGlowColor || nextGlow;\r\n      } else {\r\n        const varDot = resolveCssVariable(container, colorLightVar);\r\n        const varGlow = resolveCssVariable(container, glowColorLightVar);\r\n        nextColor = varDot || nextColor;\r\n        nextGlow = varGlow || nextGlow;\r\n      }\r\n\r\n      setResolvedColor(nextColor);\r\n      setResolvedGlowColor(nextGlow);\r\n    };\r\n\r\n    compute();\r\n\r\n    const mql = window.matchMedia\r\n      ? window.matchMedia(\"(prefers-color-scheme: dark)\")\r\n      : null;\r\n    const handleMql = () => compute();\r\n    mql?.addEventListener?.(\"change\", handleMql);\r\n\r\n    const mo = new MutationObserver(() => compute());\r\n    mo.observe(document.documentElement, {\r\n      attributes: true,\r\n      attributeFilter: [\"class\", \"style\"],\r\n    });\r\n\r\n    return () => {\r\n      mql?.removeEventListener?.(\"change\", handleMql);\r\n      mo.disconnect();\r\n    };\r\n  }, [\r\n    color,\r\n    darkColor,\r\n    glowColor,\r\n    darkGlowColor,\r\n    colorLightVar,\r\n    colorDarkVar,\r\n    glowColorLightVar,\r\n    glowColorDarkVar,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    const el = canvasRef.current;\r\n    const container = containerRef.current;\r\n    if (!el || !container) return;\r\n\r\n    const ctx = el.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    let raf = 0;\r\n    let stopped = false;\r\n\r\n    const dpr = Math.max(1, window.devicePixelRatio || 1);\r\n\r\n    const resize = () => {\r\n      const { width, height } = container.getBoundingClientRect();\r\n      el.width = Math.max(1, Math.floor(width * dpr));\r\n      el.height = Math.max(1, Math.floor(height * dpr));\r\n      el.style.width = `${Math.floor(width)}px`;\r\n      el.style.height = `${Math.floor(height)}px`;\r\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n    };\r\n\r\n    const ro = new ResizeObserver(resize);\r\n    ro.observe(container);\r\n    resize();\r\n\r\n    // Precompute dot metadata for a medium-sized grid and regenerate on resize\r\n    let dots: { x: number; y: number; phase: number; speed: number }[] = [];\r\n\r\n    const regenDots = () => {\r\n      dots = [];\r\n      const { width, height } = container.getBoundingClientRect();\r\n      const cols = Math.ceil(width / gap) + 2;\r\n      const rows = Math.ceil(height / gap) + 2;\r\n      const min = Math.min(speedMin, speedMax);\r\n      const max = Math.max(speedMin, speedMax);\r\n      for (let i = -1; i < cols; i++) {\r\n        for (let j = -1; j < rows; j++) {\r\n          const x = i * gap + (j % 2 === 0 ? 0 : gap * 0.5); // offset every other row\r\n          const y = j * gap;\r\n          // Randomize phase and speed slightly per dot\r\n          const phase = Math.random() * Math.PI * 2;\r\n          const span = Math.max(max - min, 0);\r\n          const speed = min + Math.random() * span; // configurable rad/s\r\n          dots.push({ x, y, phase, speed });\r\n        }\r\n      }\r\n    };\r\n\r\n    const regenThrottled = () => {\r\n      regenDots();\r\n    };\r\n\r\n    regenDots();\r\n\r\n    let last = performance.now();\r\n\r\n    const draw = (now: number) => {\r\n      if (stopped) return;\r\n      const dt = (now - last) / 1000; // seconds\r\n      last = now;\r\n      const { width, height } = container.getBoundingClientRect();\r\n\r\n      ctx.clearRect(0, 0, el.width, el.height);\r\n      ctx.globalAlpha = opacity;\r\n\r\n      // optional subtle background fade for depth (defaults to 0 = transparent)\r\n      if (backgroundOpacity > 0) {\r\n        const grad = ctx.createRadialGradient(\r\n          width * 0.5,\r\n          height * 0.4,\r\n          Math.min(width, height) * 0.1,\r\n          width * 0.5,\r\n          height * 0.5,\r\n          Math.max(width, height) * 0.7,\r\n        );\r\n        grad.addColorStop(0, \"rgba(0,0,0,0)\");\r\n        grad.addColorStop(\r\n          1,\r\n          `rgba(0,0,0,${Math.min(Math.max(backgroundOpacity, 0), 1)})`,\r\n        );\r\n        ctx.fillStyle = grad as unknown as CanvasGradient;\r\n        ctx.fillRect(0, 0, width, height);\r\n      }\r\n\r\n      // animate dots\r\n      ctx.save();\r\n      ctx.fillStyle = resolvedColor;\r\n\r\n      const time = (now / 1000) * Math.max(speedScale, 0);\r\n      for (let i = 0; i < dots.length; i++) {\r\n        const d = dots[i];\r\n        // Linear triangle wave 0..1..0 for linear glow/dim\r\n        const mod = (time * d.speed + d.phase) % 2;\r\n        const lin = mod < 1 ? mod : 2 - mod; // 0..1..0\r\n        const a = 0.25 + 0.55 * lin; // 0.25..0.8 linearly\r\n\r\n        // draw glow when bright\r\n        if (a > 0.6) {\r\n          const glow = (a - 0.6) / 0.4; // 0..1\r\n          ctx.shadowColor = resolvedGlowColor;\r\n          ctx.shadowBlur = 6 * glow;\r\n        } else {\r\n          ctx.shadowColor = \"transparent\";\r\n          ctx.shadowBlur = 0;\r\n        }\r\n\r\n        ctx.globalAlpha = a * opacity;\r\n        ctx.beginPath();\r\n        ctx.arc(d.x, d.y, radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n      ctx.restore();\r\n\r\n      raf = requestAnimationFrame(draw);\r\n    };\r\n\r\n    const handleResize = () => {\r\n      resize();\r\n      regenThrottled();\r\n    };\r\n\r\n    window.addEventListener(\"resize\", handleResize);\r\n    raf = requestAnimationFrame(draw);\r\n\r\n    return () => {\r\n      stopped = true;\r\n      cancelAnimationFrame(raf);\r\n      window.removeEventListener(\"resize\", handleResize);\r\n      ro.disconnect();\r\n    };\r\n  }, [\r\n    gap,\r\n    radius,\r\n    resolvedColor,\r\n    resolvedGlowColor,\r\n    opacity,\r\n    backgroundOpacity,\r\n    speedMin,\r\n    speedMax,\r\n    speedScale,\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={className}\r\n      style={{ position: \"absolute\", inset: 0 }}\r\n    >\r\n      <canvas\r\n        ref={canvasRef}\r\n        style={{ display: \"block\", width: \"100%\", height: \"100%\" }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n",
      "type": "registry:ui"
    }
  ]
}