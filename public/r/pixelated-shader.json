{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixelated-shader",
  "type": "registry:component",
  "description": "Pixelated shader directly on your image with three js",
  "files": [
    {
      "path": "src/registry/new-york/items/pixelated-shader/components/pixelated-shader.tsx",
      "content": "/* eslint-disable */\r\n\r\n\"use client\";\r\n\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport * as THREE from \"three\";\r\n\r\ntype Props = {\r\n  src: string;\r\n  alt?: string;\r\n  className?: string;\r\n  /** Overall responsiveness multiplier: >1 is faster/snappier */\r\n  speed?: number; // default 1.5\r\n  /** How strong the distortion/aberration multiplier is */\r\n  intensity?: number; // default 1.2\r\n  /** How quickly the aberration decays each frame (bigger = quicker fade) */\r\n  decay?: number; // default 0.08\r\n  /** Width of the container (CSS value: px, %, vh, etc.) */\r\n  width?: string | number; // default \"100%\"\r\n  /** Height of the container (CSS value: px, %, vh, etc.) */\r\n  height?: string | number; // default \"auto\"\r\n  /** How the image should fit: 'cover' fills container, 'contain' shows full image */\r\n  objectFit?: \"cover\" | \"contain\"; // default \"cover\"\r\n};\r\n\r\nexport default function PixedlatedShader({\r\n  src,\r\n  alt = \"\",\r\n  className = \"\",\r\n  speed = 1.5,\r\n  intensity = 1.2,\r\n  decay = 0.08,\r\n  width = \"100%\",\r\n  height = \"auto\",\r\n  objectFit = \"cover\",\r\n}: Props) {\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\r\n  const sceneRef = useRef<THREE.Scene | null>(null);\r\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\r\n  const planeRef = useRef<THREE.Mesh | null>(null);\r\n  const reqRef = useRef<number | null>(null);\r\n\r\n  const mousePos = useRef({ x: 0.5, y: 0.5 });\r\n  const targetMouse = useRef({ x: 0.5, y: 0.5 });\r\n  const prevMouse = useRef({ x: 0.5, y: 0.5 });\r\n  const aberration = useRef(0);\r\n  const ease = useRef(0.02);\r\n\r\n  const vertexShader = `\r\n    varying vec2 vUv;\r\n    void main() {\r\n      vUv = uv;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }\r\n  `;\r\n\r\n  const fragmentShader = `\r\n    varying vec2 vUv;\r\n    uniform sampler2D u_texture;    \r\n    uniform vec2 u_mouse;\r\n    uniform vec2 u_prevMouse;\r\n    uniform float u_aberrationIntensity;\r\n    uniform float u_strength;\r\n\r\n    void main() {\r\n        vec2 gridUV = floor(vUv * vec2(20.0, 20.0)) / vec2(20.0, 20.0);\r\n        vec2 centerOfPixel = gridUV + vec2(1.0/20.0, 1.0/20.0);\r\n        \r\n        vec2 mouseDirection = u_mouse - u_prevMouse;\r\n        \r\n        vec2 pixelToMouseDirection = centerOfPixel - u_mouse;\r\n        float pixelDistanceToMouse = length(pixelToMouseDirection);\r\n        float strength = smoothstep(0.3, 0.0, pixelDistanceToMouse);\r\n \r\n        vec2 uvOffset = strength * - mouseDirection * (0.2 * u_strength);\r\n        vec2 uv = vUv - uvOffset;\r\n\r\n        vec4 colorR = texture2D(u_texture, uv + vec2(strength * u_aberrationIntensity * 0.01, 0.0));\r\n        vec4 colorG = texture2D(u_texture, uv);\r\n        vec4 colorB = texture2D(u_texture, uv - vec2(strength * u_aberrationIntensity * 0.01, 0.0));\r\n\r\n        gl_FragColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);\r\n    }\r\n  `;\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    const containerEl = container;\r\n\r\n    const absUrl = (() => {\r\n      if (src.startsWith(\"http\") || src.startsWith(\"//\")) return src;\r\n      return `${window.location.origin}${src.startsWith(\"/\") ? src : \"/\" + src}`;\r\n    })();\r\n\r\n    let material: THREE.ShaderMaterial | null = null;\r\n    let planeGeo: THREE.PlaneGeometry | null = null;\r\n    let textureLoaded: THREE.Texture | null = null;\r\n\r\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n    renderer.domElement.style.position = \"absolute\";\r\n    renderer.domElement.style.inset = \"0\";\r\n    renderer.domElement.style.width = \"100%\";\r\n    renderer.domElement.style.height = \"100%\";\r\n    rendererRef.current = renderer;\r\n    containerEl.appendChild(renderer.domElement);\r\n\r\n    const scene = new THREE.Scene();\r\n    sceneRef.current = scene;\r\n    const camera = new THREE.PerspectiveCamera(80, 1, 0.01, 10);\r\n    camera.position.z = 1;\r\n    cameraRef.current = camera;\r\n\r\n    const ro = new ResizeObserver(() => {\r\n      if (!containerEl || !rendererRef.current || !cameraRef.current) return;\r\n      const rect = containerEl.getBoundingClientRect();\r\n      if (rect.width === 0 || rect.height === 0) return;\r\n      rendererRef.current.setSize(\r\n        Math.floor(rect.width),\r\n        Math.floor(rect.height),\r\n        false,\r\n      );\r\n      cameraRef.current.aspect = rect.width / rect.height;\r\n      cameraRef.current.updateProjectionMatrix();\r\n\r\n      if (planeRef.current && textureLoaded) {\r\n        updatePlaneSize(rect, textureLoaded);\r\n      }\r\n    });\r\n    ro.observe(containerEl);\r\n\r\n    function updatePlaneSize(rect: DOMRect, texture: THREE.Texture) {\r\n      if (!planeRef.current) return;\r\n\r\n      const imageAspect = texture.image.width / texture.image.height;\r\n      const containerAspect = rect.width / rect.height;\r\n\r\n      let planeWidth, planeHeight;\r\n\r\n      if (objectFit === \"cover\") {\r\n        if (imageAspect > containerAspect) {\r\n          planeHeight = 2;\r\n          planeWidth = 2 * containerAspect;\r\n        } else {\r\n          planeWidth = 2;\r\n          planeHeight = 2 / containerAspect;\r\n        }\r\n      } else {\r\n        if (imageAspect > containerAspect) {\r\n          planeWidth = 2;\r\n          planeHeight = 2 / imageAspect;\r\n        } else {\r\n          planeHeight = 2;\r\n          planeWidth = 2 * imageAspect;\r\n        }\r\n      }\r\n\r\n      if (planeGeo) {\r\n        planeGeo.dispose();\r\n      }\r\n      planeGeo = new THREE.PlaneGeometry(planeWidth, planeHeight);\r\n      planeRef.current.geometry = planeGeo;\r\n    }\r\n\r\n    const loader = new THREE.TextureLoader();\r\n    (loader as any).crossOrigin = \"anonymous\";\r\n\r\n    loader.load(\r\n      absUrl,\r\n      (texture) => {\r\n        texture.minFilter = THREE.LinearFilter;\r\n        texture.generateMipmaps = false;\r\n        texture.needsUpdate = true;\r\n        textureLoaded = texture;\r\n\r\n        const uniforms: any = {\r\n          u_mouse: { value: new THREE.Vector2(0.5, 0.5) },\r\n          u_prevMouse: { value: new THREE.Vector2(0.5, 0.5) },\r\n          u_aberrationIntensity: { value: 0.0 },\r\n          u_texture: { value: texture },\r\n          u_strength: { value: intensity },\r\n        };\r\n\r\n        material = new THREE.ShaderMaterial({\r\n          uniforms,\r\n          vertexShader,\r\n          fragmentShader,\r\n        });\r\n\r\n        const rect = containerEl.getBoundingClientRect();\r\n        const imageAspect = texture.image.width / texture.image.height;\r\n        const containerAspect = rect.width / rect.height;\r\n\r\n        let planeWidth, planeHeight;\r\n\r\n        if (objectFit === \"cover\") {\r\n          if (imageAspect > containerAspect) {\r\n            planeHeight = 2;\r\n            planeWidth = 2 * containerAspect;\r\n          } else {\r\n            planeWidth = 2;\r\n            planeHeight = 2 / containerAspect;\r\n          }\r\n        } else {\r\n          if (imageAspect > containerAspect) {\r\n            planeWidth = 2;\r\n            planeHeight = 2 / imageAspect;\r\n          } else {\r\n            planeHeight = 2;\r\n            planeWidth = 2 * imageAspect;\r\n          }\r\n        }\r\n\r\n        planeGeo = new THREE.PlaneGeometry(planeWidth, planeHeight);\r\n        const plane = new THREE.Mesh(planeGeo, material);\r\n        planeRef.current = plane;\r\n        scene.add(plane);\r\n\r\n        const ACTIVE_EASE = Math.min(0.9, 0.08 * speed + 0.04);\r\n        const LEAVE_EASE = 0.06;\r\n\r\n        function animate() {\r\n          mousePos.current.x +=\r\n            (targetMouse.current.x - mousePos.current.x) * ease.current;\r\n          mousePos.current.y +=\r\n            (targetMouse.current.y - mousePos.current.y) * ease.current;\r\n\r\n          if (material) {\r\n            (material.uniforms.u_mouse.value as THREE.Vector2).set(\r\n              mousePos.current.x,\r\n              1.0 - mousePos.current.y,\r\n            );\r\n            (material.uniforms.u_prevMouse.value as THREE.Vector2).set(\r\n              prevMouse.current.x,\r\n              1.0 - prevMouse.current.y,\r\n            );\r\n\r\n            aberration.current = Math.max(0.0, aberration.current - decay);\r\n            material.uniforms.u_aberrationIntensity.value = aberration.current;\r\n          }\r\n\r\n          if (renderer && camera && scene) {\r\n            renderer.render(scene, camera);\r\n          }\r\n\r\n          reqRef.current = requestAnimationFrame(animate);\r\n        }\r\n\r\n        if (!reqRef.current) reqRef.current = requestAnimationFrame(animate);\r\n\r\n        function setActiveEase() {\r\n          ease.current = ACTIVE_EASE;\r\n        }\r\n        function setLeaveEase() {\r\n          ease.current = LEAVE_EASE;\r\n        }\r\n\r\n        containerEl.addEventListener(\"pointerdown\", setActiveEase);\r\n        containerEl.addEventListener(\"pointerup\", setLeaveEase);\r\n\r\n        const cleanupEaseListeners = () => {\r\n          containerEl.removeEventListener(\"pointerdown\", setActiveEase);\r\n          containerEl.removeEventListener(\"pointerup\", setLeaveEase);\r\n        };\r\n\r\n        (cleanupEaseListenersRef as any).current = cleanupEaseListeners;\r\n      },\r\n      undefined,\r\n      (err) => {\r\n        console.error(\r\n          \"DistortionShaderFast: texture failed to load\",\r\n          absUrl,\r\n          err,\r\n        );\r\n      },\r\n    );\r\n\r\n    function handleMove(e: PointerEvent) {\r\n      ease.current = Math.min(0.9, 0.08 * speed + 0.04);\r\n      const rect = containerEl.getBoundingClientRect();\r\n      prevMouse.current = { ...targetMouse.current };\r\n      targetMouse.current.x = (e.clientX - rect.left) / rect.width;\r\n      targetMouse.current.y = (e.clientY - rect.top) / rect.height;\r\n      aberration.current = Math.min(3.0, 1.0 * speed * intensity + 0.5);\r\n    }\r\n    function handleEnter(e: PointerEvent) {\r\n      ease.current = Math.min(0.9, 0.12 * speed + 0.05);\r\n      const rect = containerEl.getBoundingClientRect();\r\n      targetMouse.current.x = (e.clientX - rect.left) / rect.width;\r\n      targetMouse.current.y = (e.clientY - rect.top) / rect.height;\r\n      mousePos.current.x = targetMouse.current.x;\r\n      mousePos.current.y = targetMouse.current.y;\r\n      aberration.current = Math.min(3.0, 1.0 * speed * intensity + 0.5);\r\n    }\r\n    function handleLeave() {\r\n      ease.current = 0.06;\r\n      targetMouse.current = { ...prevMouse.current };\r\n    }\r\n\r\n    containerEl.addEventListener(\"pointermove\", handleMove);\r\n    containerEl.addEventListener(\"pointerenter\", handleEnter);\r\n    containerEl.addEventListener(\"pointerleave\", handleLeave);\r\n\r\n    const cleanupEaseListenersRef = { current: null as null | (() => void) };\r\n\r\n    return () => {\r\n      ro.disconnect();\r\n      containerEl.removeEventListener(\"pointermove\", handleMove);\r\n      containerEl.removeEventListener(\"pointerenter\", handleEnter);\r\n      containerEl.removeEventListener(\"pointerleave\", handleLeave);\r\n\r\n      if ((cleanupEaseListenersRef as any).current) {\r\n        (cleanupEaseListenersRef as any).current();\r\n      }\r\n\r\n      if (reqRef.current) cancelAnimationFrame(reqRef.current);\r\n      reqRef.current = null;\r\n\r\n      if (planeRef.current) {\r\n        scene.remove(planeRef.current);\r\n        planeRef.current = null;\r\n      }\r\n\r\n      if (planeGeo) {\r\n        planeGeo.dispose();\r\n        planeGeo = null;\r\n      }\r\n\r\n      if (material) {\r\n        material.dispose();\r\n        material = null;\r\n      }\r\n\r\n      if (textureLoaded) {\r\n        textureLoaded.dispose();\r\n        textureLoaded = null;\r\n      }\r\n\r\n      if (rendererRef.current) {\r\n        const canvas = rendererRef.current.domElement;\r\n        rendererRef.current.dispose();\r\n        if (canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas);\r\n        rendererRef.current = null;\r\n      }\r\n\r\n      sceneRef.current = null;\r\n      cameraRef.current = null;\r\n    };\r\n  }, [src, speed, intensity, decay, objectFit]);\r\n\r\n  const widthStyle = typeof width === \"number\" ? `${width}px` : width;\r\n  const heightStyle = typeof height === \"number\" ? `${height}px` : height;\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`relative overflow-hidden rounded-md ${className}`}\r\n      aria-label={alt}\r\n      role=\"img\"\r\n      style={{\r\n        width: widthStyle,\r\n        height: heightStyle,\r\n        minHeight: height === \"auto\" ? 200 : undefined,\r\n      }}\r\n    />\r\n  );\r\n}\r\n\r\n// Example usage:\r\n// <DistortImage\r\n//   src=\"/image.jpg\"\r\n//   width=\"500px\"\r\n//   height=\"400px\"\r\n//   objectFit=\"cover\"\r\n//   speed={1.5}\r\n//   intensity={1.2}\r\n// />\r\n\r\n// speed: increases how quickly the mesh follows the mouse. Typical range: 0.6 (soft) → 3.0 (very snappy).\r\n\r\n// intensity: multiplies the displacement magnitude. Typical range: 0.5 → 2.5.\r\n\r\n// decay: per-frame subtract from aberration. Bigger = shorter burst (quicker fade). Typical range: 0.02 → 0.2.\r\n",
      "type": "registry:ui"
    }
  ]
}